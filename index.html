<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>1DCA</title>
</head>
<body>
	<div>
		<h3 id='r'></h3>
		<p>
			<a href='#' id='retry'>retry (same as f5)</a> | <a id='another' href='#'>get another rule</a> <br>
		</p>
		<p id='s'></p>
	</div>
</body>
<script src='js/underscore-min.js'></script>
<script src='js/backbone-min.js'></script>
<script src='js/jquery.min.js'></script>
<script>
/*
	Copyright 2015 Francisco Demartino

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

var scaleFactor = 2;

var _w  = Math.floor(document.body.clientWidth/32/scaleFactor);

var drawTimeouts = [];

var rule;
var chunkWidth  = _w * 32;
var chunkHeight = 320;
var maxPages = -1; // -1 for unlimited

var states;
var line;
var ctx;
var pages;

function createLine() {
	return new Uint32Array(_w);
}

function getBit(d, i) {
	return (d[i/32|0] >> (i%32)) & 1;
}

function setBit(d, i) {
	d[i/32|0] |= 1<<(i%32);
	return d;
}

function serialize(d) {
	var s = '' + _w + '.';
	for (var i=0; i<_w; i++) {
		for (var j=0; j<4; j++) {
			var cc = (d[i] >> (j * 8)) & 0xFF;
			s += cc.toString();
		}
	}
	return '' + chunkWidth  + '.' + s;
}

function _step(d, l, c, r, i) {
	if (rule >> ( (getBit(d, l) << 2)
	            | (getBit(d, c) << 1)
	            | (getBit(d, r) << 0)
	            ) & 1)
		return setBit(i, c);
	return i;
}

function step(d, w) {
	var n = createLine();

	    n = _step(d, w-1,   0,   1, n);
	for(i = 1; i < w-1; i++) {
	    n = _step(d, i-1,   i, i+1, n);
	}
	    n = _step(d, w-2, w-1,   0, n);

	return n;
}

function automateTimeout(d) {
	if (_automate(d)) {
		drawTimeouts.push(setTimeout(function() {automateTimeout(step(d, chunkWidth))}, 0));
	}
}

function automateWhile(_d) {
	var d = _d;
	while(_automate(d)) {
		d = step(d, chunkWidth);
	}
}

function _automate(d) {

	if (line == chunkHeight) {
		line = 0;
		if (!newPage()) {
			document.body.style.backgroundColor = "#EDB";
			return;
		}
	}

	addLine(d);

	var s = serialize(d);

	if (states[s]) {
		document.body.style.backgroundColor = "#BDE";
		return;
	}

	states[s] = 1;

	return true;
}

function newPage() {
	if (!--pages) { return false;}

	var canvas = document.createElement('canvas');
	canvas.width = chunkWidth;
	canvas.height = chunkHeight;
	canvas.style.zoom = scaleFactor;
	document.body.appendChild(canvas);

	ctx = canvas.getContext('2d');

	return true;
}

function clearPages() {
	$('canvas').remove();
	ctx = null;
	pages = maxPages;
}

function clearDrawTimeouts() {
	for (var i=0; i<drawTimeouts.length; i++) {
		clearTimeout(drawTimeouts[i]);
	}
}

function addLine(current) {
	var px = ctx.getImageData(0, line, chunkWidth , 1);

	for (var i = 0; i < chunkWidth ; i++) {
		px.data[4*i+3] = getBit(current, i) ? 0xFF: 0x00;
		//for(var j=0; j<3; j++) {
		//	px.data[4*i+j] = getBit(current, i) ? 0x00: 0xFF;
		//}
	}

	ctx.putImageData(px, 0, line);
	line++;
}

function bitJoin(bs, reverse) {
	var m = reverse ? -1 : 1;
	var s = reverse ?  7 : 0;

	var ac = 0;
	for (var i = 0; i<8; i++) {
	  ac |= (bs[i] << (s + m*i));
	}
	return ac;
}

function bitSplit(n) {
	var bs = [];

	for (var i = 0; i<8; i++) {
		bs[i] = (n >> i) & 1;
	}
	return bs;
}

function family(rule) {

	//  7   6   5   4   3   2   1   0
	// 111 110 101 100 011 010 001 000

	//  A   B   C   D   E   F   G   H    rule
	//  A   E   C   G   B   F   D   H    mirror   (flipped on x axis)
	// ¬H  ¬G  ¬F  ¬E  ¬D  ¬C  ¬B  ¬A    negative  (inverted zeros and ones)

	var mirror = function(n) {
		var bs = bitSplit(n);
		var _mirror_bs = _.clone(bs);
		_mirror_bs[6] = bs[3];
		_mirror_bs[4] = bs[1];
		_mirror_bs[3] = bs[6];
		_mirror_bs[1] = bs[4];
		return bitJoin(_mirror_bs);
	};

	var negative = function(n) {
		return bitJoin(bitSplit(n ^ ((1 << 8) - 1)), true);
	};

	return {
		mirror: mirror(rule),
		negative: negative(rule),
		mirgative: mirror(negative(rule))
	};

}

var Router = Backbone.Router.extend({

	routes: {
		"rule/:r": "rule",
		"(/*foo)":     "rule",
	},

	rule: function(r) {
		rule = r;
		if (!parseInt(r)) {
			rule = Math.floor(Math.random() * 256);
			this.navigate('rule/' + rule);
		}
		init();
	},


});

function init() {
	states = {};
	line = 0;
	clearDrawTimeouts();
	clearPages();

	document.getElementById('r').innerHTML = document.title = "1DCA | Rule " + rule;

	var f = family(rule);
	document.getElementById('s').innerHTML = "related: <a href='#rule/"  + f.negative + "'>" + f.negative + " (negative)</a>";
	if (f.mirror != rule) {
		document.getElementById('s').innerHTML += " - <a href='#rule/"  + f.mirror + "'>" + f.mirror + " (mirror)</a>";
		document.getElementById('s').innerHTML += " - <a href='#rule/"  + f.mirgative + "'>" + f.mirgative + " (mirr-gative?)</a>";
	}

	var last = createLine();

	for(i = 0; i < chunkWidth -1; i++) {
		if (Math.random() > .5) {
			last = setBit(last, i);
		}
	}

	document.body.style.backgroundColor = "#EEE";

	newPage();
	setTimeout(function() { window.scrollTo(0, 0); }, 0);
	automateTimeout(last);
}

var app = new Router();
Backbone.history.start();

$('#retry').click(function(e){
	e.preventDefault();
	app.rule(rule);
});

$('#another').click(function(e){
	e.preventDefault();
	app.rule();
});

</script>
<style>
div {
	margin: 0 16px;
}
body {
	margin: 16px 0;
	overflow-y: scroll;
}
canvas {
	display: block;
	margin: auto;
	image-rendering: pixelated;
}
</style>
</html>
